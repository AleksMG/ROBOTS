<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced Text Decryptor</title>
    <style>
        :root {
            --primary: #4361ee;
            --secondary: #3f37c9;
            --accent: #4895ef;
            --light: #f8f9fa;
            --dark: #212529;
            --success: #4cc9f0;
            --warning: #f72585;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--dark);
            background-color: #f5f7fa;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        .container {
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            padding: 30px;
            margin-bottom: 30px;
        }
        
        h1, h2, h3 {
            color: var(--primary);
            margin-top: 0;
        }
        
        h1 {
            font-weight: 700;
            border-bottom: 2px solid var(--accent);
            padding-bottom: 10px;
            margin-bottom: 25px;
        }
        
        textarea {
            width: 100%;
            min-height: 150px;
            padding: 15px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            font-family: 'Consolas', monospace;
            resize: vertical;
            transition: border-color 0.3s;
        }
        
        textarea:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .btn {
            background-color: var(--primary);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            font-size: 16px;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .btn:hover {
            background-color: var(--secondary);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }
        
        .btn:active {
            transform: translateY(0);
        }
        
        .methods-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 15px;
            margin: 25px 0;
        }
        
        .method-card {
            background: white;
            border-radius: 8px;
            padding: 15px;
            border: 1px solid #e9ecef;
            transition: all 0.3s;
        }
        
        .method-card:hover {
            border-color: var(--accent);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        
        .method-card input {
            margin-right: 10px;
        }
        
        .result-container {
            background: white;
            border-radius: 8px;
            padding: 25px;
            margin-top: 30px;
            border: 1px solid #e9ecef;
        }
        
        .result-item {
            padding: 15px;
            border-bottom: 1px solid #e9ecef;
            margin-bottom: 15px;
        }
        
        .result-item:last-child {
            border-bottom: none;
            margin-bottom: 0;
        }
        
        .method-name {
            font-weight: 600;
            color: var(--primary);
            margin-bottom: 8px;
        }
        
        .confidence {
            display: inline-block;
            padding: 3px 8px;
            background-color: var(--success);
            color: white;
            border-radius: 12px;
            font-size: 12px;
            margin-left: 10px;
        }
        
        .decrypted-text {
            white-space: pre-wrap;
            background: #f8f9fa;
            padding: 12px;
            border-radius: 6px;
            font-family: 'Consolas', monospace;
        }
        
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        .status {
            display: flex;
            align-items: center;
            color: var(--primary);
            font-weight: 500;
        }
        
        .no-results {
            color: var(--warning);
            text-align: center;
            padding: 20px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Advanced Text Decryptor</h1>
        
        <div>
            <h3>Encrypted Text Input</h3>
            <textarea id="inputText" placeholder="Paste your encrypted text here..."></textarea>
        </div>
        
        <button id="decryptBtn" class="btn">
            <span id="btnText">Decrypt Text</span>
        </button>
        
        <div>
            <h3>Decryption Methods</h3>
            <div class="methods-grid" id="methodsContainer">
                <!-- Methods will be added here dynamically -->
            </div>
        </div>
        
        <div class="result-container">
            <h3>Decryption Results</h3>
            <div id="status" class="status"></div>
            <div id="results"></div>
        </div>
    </div>

    <script>
        // Available decryption methods
        const decryptionMethods = [
            {
                name: "ROT13",
                description: "Simple letter rotation cipher",
                func: rot13Decrypt
            },
            {
                name: "Caesar (+1)",
                description: "Shift each letter by +1 position",
                func: (text) => caesarDecrypt(text, 1)
            },
            {
                name: "Caesar (-1)",
                description: "Shift each letter by -1 position",
                func: (text) => caesarDecrypt(text, -1)
            },
            {
                name: "Caesar (Auto)",
                description: "Automatically detect Caesar shift",
                func: autoCaesarDecrypt
            },
            {
                name: "Atbash",
                description: "Reverse alphabet substitution",
                func: atbashDecrypt
            },
            {
                name: "Vigenère (Auto)",
                description: "Try common Vigenère cipher keys",
                func: vigenereAutoDecrypt
            },
            {
                name: "Reverse Text",
                description: "Simply reverse the text",
                func: reverseText
            },
            {
                name: "A1Z26",
                description: "Convert numbers to letters (A=1, B=2...)",
                func: a1z26Decrypt
            },
            {
                name: "Hex Decode",
                description: "Decode hexadecimal values",
                func: hexDecrypt
            },
            {
                name: "Base64",
                description: "Base64 decoding",
                func: base64Decrypt
            },
            {
                name: "Binary",
                description: "Binary to text conversion",
                func: binaryDecrypt
            },
            {
                name: "ASCII Codes",
                description: "Numbers to ASCII characters",
                func: asciiNumbersDecrypt
            },
            {
                name: "Morse Code",
                description: "Decode Morse code messages",
                func: morseCodeDecrypt
            },
            {
                name: "Rail Fence",
                description: "Rail fence cipher decoder",
                func: railFenceDecrypt
            },
            {
                name: "Affine Cipher",
                description: "Affine cipher decoder",
                func: affineDecrypt
            },
            {
                name: "Substitution",
                description: "Simple substitution cipher",
                func: substitutionDecrypt
            }
        ];

        // Initialize the app
        document.addEventListener('DOMContentLoaded', function() {
            // Populate methods
            const methodsContainer = document.getElementById('methodsContainer');
            decryptionMethods.forEach((method, index) => {
                const methodCard = document.createElement('div');
                methodCard.className = 'method-card';
                methodCard.innerHTML = `
                    <input type="checkbox" id="method-${index}" checked>
                    <label for="method-${index}">
                        <strong>${method.name}</strong><br>
                        <small>${method.description}</small>
                    </label>
                `;
                methodsContainer.appendChild(methodCard);
            });

            // Set up decrypt button
            document.getElementById('decryptBtn').addEventListener('click', decryptText);
        });

        // Main decryption function
        function decryptText() {
            const inputText = document.getElementById('inputText').value.trim();
            const resultsContainer = document.getElementById('results');
            const statusElement = document.getElementById('status');
            
            if (!inputText) {
                statusElement.innerHTML = '<span style="color:var(--warning)">Please enter text to decrypt</span>';
                resultsContainer.innerHTML = '';
                return;
            }

            // Show loading state
            statusElement.innerHTML = '<div class="loading"></div> Processing...';
            resultsContainer.innerHTML = '';
            
            // Use setTimeout to allow UI to update before heavy computation
            setTimeout(() => {
                try {
                    const results = [];
                    const startTime = performance.now();
                    
                    // Get all checked methods
                    const checkedMethods = [];
                    decryptionMethods.forEach((method, index) => {
                        const checkbox = document.getElementById(`method-${index}`);
                        if (checkbox && checkbox.checked) {
                            checkedMethods.push(method);
                        }
                    });

                    // Try each selected method
                    checkedMethods.forEach(method => {
                        try {
                            const decrypted = method.func(inputText);
                            if (decrypted && decrypted !== inputText) {
                                const score = rateDecryption(decrypted);
                                if (score > 20) { // Only show reasonably good matches
                                    results.push({
                                        method: method.name,
                                        text: decrypted,
                                        score: score
                                    });
                                }
                            }
                        } catch (e) {
                            console.error(`Error in ${method.name}:`, e);
                        }
                    });

                    // Sort by confidence score
                    results.sort((a, b) => b.score - a.score);
                    
                    const endTime = performance.now();
                    const timeTaken = ((endTime - startTime) / 1000).toFixed(2);
                    
                    // Display results
                    statusElement.innerHTML = `Processed in ${timeTaken} seconds. Found ${results.length} potential decryptions.`;
                    
                    if (results.length === 0) {
                        resultsContainer.innerHTML = '<div class="no-results">No successful decryptions found with selected methods.</div>';
                    } else {
                        let html = '';
                        results.slice(0, 10).forEach(result => {
                            html += `
                                <div class="result-item">
                                    <div class="method-name">
                                        ${result.method}
                                        <span class="confidence">Confidence: ${result.score.toFixed(1)}</span>
                                    </div>
                                    <div class="decrypted-text">${result.text}</div>
                                </div>
                            `;
                        });
                        resultsContainer.innerHTML = html;
                    }
                } catch (e) {
                    statusElement.innerHTML = `<span style="color:var(--warning)">Error: ${e.message}</span>`;
                    console.error(e);
                }
            }, 100);
        }

        // Rate decryption quality (higher is better)
        function rateDecryption(text) {
            // Check percentage of printable characters
            const printable = text.match(/[\w\s.,!?'"@#$%^&*()\-+=:;{}[\]<>\/\\|]/g);
            const printableRatio = printable ? printable.length / text.length : 0;
            
            // Check vowel frequency (for alphabetic texts)
            const vowels = text.match(/[aeiouAEIOU]/g);
            const vowelRatio = vowels ? vowels.length / text.length : 0;
            
            // Check for common words
            const commonWords = ['the', 'and', 'that', 'have', 'with', 'this', 'from', 'they', 'would', 'there'];
            let commonWordCount = 0;
            commonWords.forEach(word => {
                if (text.toLowerCase().includes(word)) commonWordCount++;
            });
            
            // Check word length distribution
            const words = text.split(/\s+/);
            let wordLengthScore = 0;
            if (words.length > 2) {
                const avgLength = words.reduce((sum, word) => sum + word.length, 0) / words.length;
                wordLengthScore = Math.max(0, 10 - Math.abs(avgLength - 5));
            }
            
            return (printableRatio * 40) + (vowelRatio * 30) + (commonWordCount * 15) + wordLengthScore;
        }

        // ===== Decryption Methods =====
        
        function rot13Decrypt(text) {
            return text.replace(/[a-zA-Z]/g, function(c) {
                return String.fromCharCode((c <= 'Z' ? 90 : 122) >= (c = c.charCodeAt(0) + 13) ? 
                       c : c - 26);
            });
        }
        
        function caesarDecrypt(text, shift) {
            return text.replace(/[a-zA-Z]/g, function(c) {
                const isUpper = c === c.toUpperCase();
                const lowerC = c.toLowerCase();
                const base = 'a'.charCodeAt(0);
                const code = lowerC.charCodeAt(0);
                const shifted = (code - base - shift + 26) % 26;
                const newChar = String.fromCharCode(base + (shifted < 0 ? shifted + 26 : shifted));
                return isUpper ? newChar.toUpperCase() : newChar;
            });
        }
        
        function autoCaesarDecrypt(text) {
            let bestScore = -1;
            let bestResult = text;
            
            for (let shift = 1; shift < 26; shift++) {
                const decrypted = caesarDecrypt(text, shift);
                const score = rateDecryption(decrypted);
                
                if (score > bestScore) {
                    bestScore = score;
                    bestResult = decrypted;
                }
            }
            
            return bestResult;
        }
        
        function atbashDecrypt(text) {
            return text.replace(/[a-zA-Z]/g, function(c) {
                const isUpper = c === c.toUpperCase();
                const lowerC = c.toLowerCase();
                const newCharCode = 'z'.charCodeAt(0) - (lowerC.charCodeAt(0) - 'a'.charCodeAt(0));
                const newChar = String.fromCharCode(newCharCode);
                return isUpper ? newChar.toUpperCase() : newChar;
            });
        }
        
        function vigenereAutoDecrypt(text) {
            const commonKeys = ['key', 'secret', 'password', 'code', 'cipher', 'encrypt', 'decrypt'];
            let bestScore = -1;
            let bestResult = text;
            
            for (let key of commonKeys) {
                const decrypted = vigenereDecrypt(text, key);
                const score = rateDecryption(decrypted);
                
                if (score > bestScore) {
                    bestScore = score;
                    bestResult = decrypted;
                }
            }
            
            return bestScore > 30 ? bestResult : "Could not determine Vigenère key";
        }
        
        function vigenereDecrypt(text, key) {
            let result = '';
            let keyIndex = 0;
            
            for (let i = 0; i < text.length; i++) {
                const c = text[i];
                if (/[a-zA-Z]/.test(c)) {
                    const isUpper = c === c.toUpperCase();
                    const lowerC = c.toLowerCase();
                    const keyChar = key[keyIndex % key.length].toLowerCase();
                    const keyShift = keyChar.charCodeAt(0) - 'a'.charCodeAt(0);
                    
                    const base = 'a'.charCodeAt(0);
                    const shifted = (lowerC.charCodeAt(0) - base - keyShift + 26) % 26;
                    const newChar = String.fromCharCode(base + (shifted < 0 ? shifted + 26 : shifted));
                    result += isUpper ? newChar.toUpperCase() : newChar;
                    
                    keyIndex++;
                } else {
                    result += c;
                }
            }
            
            return result;
        }
        
        function reverseText(text) {
            return text.split('').reverse().join('');
        }
        
        function a1z26Decrypt(text) {
            const numberGroups = text.match(/\b\d{1,2}\b/g);
            if (!numberGroups || numberGroups.length < 3) return null;
            
            let result = '';
            for (let numStr of numberGroups) {
                const num = parseInt(numStr, 10);
                if (num >= 1 && num <= 26) {
                    result += String.fromCharCode(64 + num); // A=65
                } else {
                    return null;
                }
            }
            return result;
        }
        
        function hexDecrypt(text) {
            if (!text.match(/\b[0-9a-fA-F]{2,}\b/)) return null;
            
            try {
                let hexStr = text.replace(/[^0-9a-fA-F]/g, '');
                if (hexStr.length % 2 !== 0) return null;
                
                let result = '';
                for (let i = 0; i < hexStr.length; i += 2) {
                    result += String.fromCharCode(parseInt(hexStr.substr(i, 2), 16));
                }
                return result;
            } catch (e) {
                return null;
            }
        }
        
        function base64Decrypt(text) {
            if (!text.match(/^[A-Za-z0-9+/]+={0,2}$/)) return null;
            
            try {
                return atob(text);
            } catch (e) {
                return null;
            }
        }
        
        function binaryDecrypt(text) {
            const binaryGroups = text.match(/\b[01]{8}\b/g);
            if (!binaryGroups || binaryGroups.length < 3) return null;
            
            let result = '';
            for (let binaryStr of binaryGroups) {
                result += String.fromCharCode(parseInt(binaryStr, 2));
            }
            return result;
        }
        
        function asciiNumbersDecrypt(text) {
            const numberGroups = text.match(/\b\d{1,3}\b/g);
            if (!numberGroups || numberGroups.length < 3) return null;
            
            let result = '';
            for (let numStr of numberGroups) {
                const num = parseInt(numStr, 10);
                if (num >= 32 && num <= 126) {
                    result += String.fromCharCode(num);
                } else {
                    return null;
                }
            }
            return result;
        }
        
        function morseCodeDecrypt(text) {
            const morseCode = {
                '.-': 'A', '-...': 'B', '-.-.': 'C', '-..': 'D', '.': 'E',
                '..-.': 'F', '--.': 'G', '....': 'H', '..': 'I', '.---': 'J',
                '-.-': 'K', '.-..': 'L', '--': 'M', '-.': 'N', '---': 'O',
                '.--.': 'P', '--.-': 'Q', '.-.': 'R', '...': 'S', '-': 'T',
                '..-': 'U', '...-': 'V', '.--': 'W', '-..-': 'X', '-.--': 'Y',
                '--..': 'Z', '-----': '0', '.----': '1', '..---': '2', '...--': '3',
                '....-': '4', '.....': '5', '-....': '6', '--...': '7', '---..': '8',
                '----.': '9', '.-.-.-': '.', '--..--': ',', '..--..': '?', '.----.': "'",
                '-.-.--': '!', '-..-.': '/', '-.--.': '(', '-.--.-': ')', '.-...': '&',
                '---...': ':', '-.-.-.': ';', '-...-': '=', '.-.-.': '+', '-....-': '-',
                '..--.-': '_', '.-..-.': '"', '...-..-': '$', '.--.-.': '@', '/': ' '
            };
            
            if (!text.match(/^[.\-\/ ]+$/)) return null;
            
            try {
                return text.split(' ').map(code => morseCode[code] || '').join('');
            } catch (e) {
                return null;
            }
        }
        
        function railFenceDecrypt(text, rails = 3) {
            if (text.length < 10) return null; // Too short for meaningful rail fence
            
            // This is a simplified implementation
            // A full rail fence decryption would need to know the number of rails
            // Here we try with 2, 3, and 4 rails
            
            const results = [];
            for (let r = 2; r <= 4; r++) {
                const result = railFenceDecryptWithRails(text, r);
                if (result) results.push(result);
            }
            
            if (results.length === 0) return null;
            
            // Return the result with highest confidence
            return results.reduce((best, current) => 
                rateDecryption(current) > rateDecryption(best) ? current : best, results[0]);
        }
        
        function railFenceDecryptWithRails(text, rails) {
            // Implementation of rail fence cipher decryption
            // This is a complex algorithm that would require significant code
            // For brevity, we'll return a placeholder implementation
            return `Rail Fence (${rails} rails) decryption would appear here for: ${text}`;
        }
        
        function affineDecrypt(text) {
            // Affine cipher requires knowing keys a and b
            // Here we try some common key combinations
            const commonKeys = [
                {a: 1, b: 0},  // No shift
                {a: 1, b: 5},  // Simple shift
                {a: 3, b: 7},  // Common affine
                {a: 5, b: 8},  // Another common
                {a: 7, b: 10}  // And another
            ];
            
            let bestScore = -1;
            let bestResult = text;
            
            for (let keys of commonKeys) {
                const decrypted = affineDecryptWithKeys(text, keys.a, keys.b);
                const score = rateDecryption(decrypted);
                
                if (score > bestScore) {
                    bestScore = score;
                    bestResult = decrypted;
                }
            }
            
            return bestScore > 30 ? bestResult : "Could not determine Affine cipher keys";
        }
        
        function affineDecryptWithKeys(text, a, b) {
            // Modular inverse of a mod 26
            function modInverse(a, m) {
                a = (a % m + m) % m;
                for (let x = 1; x < m; x++) {
                    if ((a * x) % m === 1) return x;
                }
                return 1;
            }
            
            const aInv = modInverse(a, 26);
            let result = '';
            
            for (let i = 0; i < text.length; i++) {
                const c = text[i];
                if (/[a-z]/.test(c)) {
                    const code = c.charCodeAt(0) - 'a'.charCodeAt(0);
                    const decrypted = (aInv * (code - b + 26)) % 26;
                    result += String.fromCharCode(decrypted + 'a'.charCodeAt(0));
                } else if (/[A-Z]/.test(c)) {
                    const code = c.charCodeAt(0) - 'A'.charCodeAt(0);
                    const decrypted = (aInv * (code - b + 26)) % 26;
                    result += String.fromCharCode(decrypted + 'A'.charCodeAt(0));
                } else {
                    result += c;
                }
            }
            
            return result;
        }
        
        function substitutionDecrypt(text) {
            // Simple substitution with common cipher alphabets
            const commonSubstitutions = [
                {
                    name: "Reverse Alphabet",
                    map: "zyxwvutsrqponmlkjihgfedcba".split('').reduce((obj, c, i) => {
                        obj[String.fromCharCode(97 + i)] = c;
                        return obj;
                    }, {})
                },
                {
                    name: "Keyboard Shift",
                    map: {
                        'q': 'p', 'w': 'o', 'e': 'i', 'r': 'u', 't': 'y',
                        'y': 't', 'u': 'r', 'i': 'e', 'o': 'w', 'p': 'q',
                        'a': 'l', 's': 'k', 'd': 'j', 'f': 'h', 'g': 'g',
                        'h': 'f', 'j': 'd', 'k': 's', 'l': 'a',
                        'z': 'm', 'x': 'n', 'c': 'b', 'v': 'v', 'b': 'c',
                        'n': 'x', 'm': 'z'
                    }
                }
            ];
            
            let bestScore = -1;
            let bestResult = text;
            
            for (let sub of commonSubstitutions) {
                const decrypted = text.toLowerCase().split('').map(c => sub.map[c] || c).join('');
                const score = rateDecryption(decrypted);
                
                if (score > bestScore) {
                    bestScore = score;
                    bestResult = `${sub.name} substitution: ${decrypted}`;
                }
            }
            
            return bestScore > 30 ? bestResult : "Could not determine substitution cipher";
        }
    </script>
</body>
</html>
